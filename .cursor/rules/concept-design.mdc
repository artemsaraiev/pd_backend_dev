---
alwaysApply: true
---

# Concept design and synchronization rules

In this project, backend is implemented using concept design-synchronization approach.
Important things to remember:

+ Actions always return a single dictionary/JSON object with the result of some type
inside it.
+ Queries start with an underscore `_` and return an array with elements being the
return value type of the query.
+ Don't use `| null` in queries; instead, just don't add any elements to the array. For
unsuccessful queries, return an empty array. If query returns a single value, return
an array with a single element.
+ In syncs, use queries through `frames.query` method.
+ Passthrough routes can be found in `src/concepts/Requesting/passthrough.ts` file.
+ Queries can't be directly called from the frontend, instead, they are used through
syncs on the backend.
+ If some action requires user authentication and verification, use `Sessioning`
concept to get the user from the session and verify their permissions in the action
synchronization.
+ paperId is a string that is used to identify a paper. PaperIndex additionally uses
_id field to identify unique papers in the database and stores paperId as a separate
field.
+ If some action can either return a success or an error, split the Response sync into
two syncs: one for the success case and one for the error case.
+ Below I've provided an example of concept design and synchronization for the
FileUploading concept. Follow this style and formatting for other concepts.

## Example of concept design and synchronization

### Concept: FileUploading \[User, File]

+ **purpose**: To manage the lifecycle and metadata of user-owned files stored in an
external cloud service.
+ **principle**: If a user requests to upload a file, they receive a unique, temporary
URL. After they upload their file directly to that URL and confirm the upload with the
system, the file is officially recorded as theirs and can be retrieved later via
another temporary download URL.
+ **state**:
  + a set of `File`s with
    + an `owner` User
    + a `filename` String
    + a `storagePath` String (e.g., the path/key of the object in the GCS bucket)
    + a `status` String (values: "pending", "uploaded")
+ **actions**:
  + `requestUploadURL (owner: User, filename: String): (file: File, uploadURL: String)`
    + **requires**: true.
    +**effects**: creates a new File `f` with status `pending`, owner `owner`, and
    filename `filename`; generates a unique `storagePath` for `f`; generates a
    presigned GCS upload URL corresponding to that path; returns the new file's ID and
    the URL.
  + `confirmUpload (file: File): ()`
    + **requires**: a File `f` exists and its status is "pending".
    + **effects**: sets the status of `f` to "uploaded".
  + `confirmUpload (file: File): (error: String)`
    + **requires**: no File `f` exists or its status is not "pending".
    + **effects**: returns an error message.
  + `delete (file: File): ()`
    + **requires**: the given `file` exists.
    + **effects**: removes the file record `f` from the state. Additionally, it
    triggers the deletion of the corresponding object from the external GCS bucket.
+ **queries**:
  + `_getOwner (file: File): (owner: User)`
    + **requires**: the given `file` exists.
    + **effects**: returns the owner of the file.
  + `_getDownloadURL (file: File): (downloadURL: String)`
    + **requires**: the given `file` exists and its status is "uploaded".
    + **effects**: generates a short-lived, presigned GCS download URL for the file `f` and returns it.
  + `_getFilesByOwner (owner: User): (file: File, filename: String)`
    + **requires**: the given `owner` exists.
    + **effects**: returns all files owned by the user with status "uploaded", along with their filenames.

## Implementation

```typescript
import { Collection, Db } from "npm:mongodb";
import { Storage } from "npm:@google-cloud/storage";
import { Empty, ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";
import { extname } from "jsr:@std/path/extname";
import { contentType } from "jsr:@std/media-types/content-type";

// Generic types used by this concept
type User = ID;
type File = ID;

// Prefix for MongoDB collections to avoid name collisions
const PREFIX = "FileUploading" + ".";

/**
 * State for a File, representing its metadata in the database.
 *
 * a set of `File`s with
 *   an `owner` User
 *   a `filename` String
 *   a `storagePath` String (e.g., the path/key of the object in the GCS bucket)
 *   a `status` String (values: "pending", "uploaded")
 */
interface FileState {
  _id: File;
  owner: User;
  filename: string;
  storagePath: string;
  status: "pending" | "uploaded";
}

/**
 * @concept FileUploading
 * @purpose To manage the lifecycle and metadata of user-owned files stored in an external cloud service.
 */
export default class FileUploadingConcept {
  public readonly files: Collection<FileState>;
  private readonly storage: Storage;
  private readonly bucketName: string;

  constructor(private readonly db: Db) {
    this.files = this.db.collection<FileState>(PREFIX + "files");

    // Initialize Google Cloud Storage client from environment variables
    this.bucketName = Deno.env.get("FILE_UPLOADING_GCS_BUCKET_NAME")!;
    const projectId = Deno.env.get("FILE_UPLOADING_GCS_PROJECT_ID");
    // The private key from the JSON file often has newlines that need to be parsed correctly
    const privateKey = Deno.env.get("FILE_UPLOADING_GCS_PRIVATE_KEY")?.replace(
      /\\n/g,
      "\n",
    );
    const clientEmail = Deno.env.get("FILE_UPLOADING_GCS_CLIENT_EMAIL");

    if (!this.bucketName || !projectId || !privateKey || !clientEmail) {
      throw new Error(
        "Missing required GCS environment variables for FileUploadingConcept. Please check your .env file.",
      );
    }

    this.storage = new Storage({
      projectId,
      credentials: {
        private_key: privateKey,
        client_email: clientEmail,
      },
    });
  }

  // === ACTIONS ===

  /**
   * requestUploadURL (owner: User, filename: String): (file: File, uploadURL: String)
   *
   * **requires**: true.
   * **effects**: creates a new File `f` with status `pending`, owner `owner`, and filename `filename`;
   *             generates a unique `storagePath` for `f`; generates a presigned GCS upload URL
   *             corresponding to that path; returns the new file's ID and the URL.
   */
  async requestUploadURL(
    { owner, filename }: { owner: User; filename: string },
  ): Promise<{ file: File; uploadURL: string } | { error: string }> {
    const newFileId = freshID() as File;
    const storagePath = `${newFileId}/${filename}`; // Use the unique ID to prevent path collisions

    const newFile: FileState = {
      _id: newFileId,
      owner,
      filename,
      storagePath,
      status: "pending",
    };

    try {
      const extension = extname(filename);
      const inferredContentType = contentType(extension) || "application/octet-stream";
      const options = {
        version: "v4" as const,
        action: "write" as const,
        expires: Date.now() + 15 * 60 * 1000, // URL is valid for 15 minutes
        contentType: inferredContentType,
      };

      const [url] = await this.storage.bucket(this.bucketName).file(storagePath)
        .getSignedUrl(options);

      await this.files.insertOne(newFile);

      return { file: newFileId, uploadURL: url };
    } catch (e) {
      console.error("FileUploadingConcept: Error generating upload URL:", e);
      return { error: "Failed to generate an upload URL." };
    }
  }

  /**
   * confirmUpload (file: File): () | (error: String)
   *
   * **requires**: a File `f` exists and its status is "pending".
   * **effects**: sets the status of `f` to "uploaded". If conditions not met, returns an error.
   */
  async confirmUpload(
    { file }: { file: File },
  ): Promise<{ file:File } | { error: string }> {
    const fileRecord = await this.files.findOne({ _id: file });

    if (!fileRecord) {
      return { error: "File not found." };
    }
    if (fileRecord.status !== "pending") {
      return {
        error:
          `File is not in 'pending' state. Current state: ${fileRecord.status}`,
      };
    }

    const result = await this.files.updateOne({ _id: file }, {
      $set: { status: "uploaded" },
    });

    if (result.modifiedCount === 0) {
      return { error: "Failed to confirm upload." };
    }

    return { file };
  }

  /**
   * delete (file: File): () | (error: String)
   *
   * **requires**: the given `file` exists.
   * **effects**: removes the file record `f` from the state. Additionally, it triggers the
   *             deletion of the corresponding object from the external GCS bucket.
   */
  async delete({ file }: { file: File }): Promise<Empty | { error: string }> {
    const fileRecord = await this.files.findOne({ _id: file });

    if (!fileRecord) {
      return { error: "File not found." };
    }

    try {
      // First, delete the object from GCS
      await this.storage.bucket(this.bucketName).file(fileRecord.storagePath)
        .delete();
      // Then, delete the record from the database
      await this.files.deleteOne({ _id: file });
      return {};
    } catch (e) {
      console.error(
        `FileUploadingConcept: Failed to delete file ${file} from GCS or DB:`,
        e,
      );
      return { error: "An error occurred during file deletion." };
    }
  }

  // === QUERIES ===

  /**
   * _getOwner (file: File): (owner: User)
   *
   * **requires**: the given `file` exists.
   * **effects**: returns the owner of the file.
   */
  async _getOwner({ file }: { file: File }): Promise<{ owner: User }[]> {
    const fileRecord = await this.files.findOne({ _id: file }, {
      projection: { owner: 1 },
    });
    return fileRecord ? [{ owner: fileRecord.owner }] : [];
  }
  
  /**
   * _getFilename (file: File): (filename: String)
   *
   * **requires**: the given `file` exists.
   * **effects**: returns the filename of the file.
   */
  async _getFilename({ file }: { file: File }): Promise<{ filename: string }[]> {
    const fileRecord = await this.files.findOne({ _id: file }, { projection: { filename: 1 } });
    return fileRecord ? [{ filename: fileRecord.filename }] : [];
  }

  /**
   * _getDownloadURL (file: File): (downloadURL: String)
   *
   * **requires**: the given `file` exists and its status is "uploaded".
   * **effects**: generates a short-lived, presigned GCS download URL for the file `f` and returns it.
   */
  async _getDownloadURL(
    { file }: { file: File },
  ): Promise<{ downloadURL: string }[]> {
    const fileRecord = await this.files.findOne({
      _id: file,
      status: "uploaded",
    });

    if (!fileRecord) {
      return [];
    }

    try {
      const options = {
        version: "v4" as const,
        action: "read" as const,
        expires: Date.now() + 15 * 60 * 1000, // URL is valid for 15 minutes
      };
      const [url] = await this.storage.bucket(this.bucketName).file(
        fileRecord.storagePath,
      ).getSignedUrl(options);
      return [{ downloadURL: url }];
    } catch (e) {
      console.error(
        `FileUploadingConcept: Failed to generate download URL for file ${file}:`,
        e,
      );
      return [];
    }
  }

  /**
   * _getFilesByOwner (owner: User): (file: File, filename: String)
   *
   * **requires**: the given `owner` exists.
   * **effects**: returns all files owned by the user with status "uploaded", along with their filenames.
   */
  async _getFilesByOwner(
    { owner }: { owner: User },
  ): Promise<{ file: File; filename: string }[]> {
    const userFiles = await this.files
      .find(
        { owner, status: "uploaded" },
        { projection: { _id: 1, filename: 1 } },
      )
      .toArray();

    return userFiles.map((doc) => ({
      file: doc._id,
      filename: doc.filename,
    }));
  }
}
```

## Syncs

```typescript
import { actions, Frames, Sync } from "@engine";
import { Requesting, Sessioning, FileUploading, Sharing, UserAuthentication } from "@concepts";

//-- Phase 1: Request Upload URL --//
export const RequestUploadURL: Sync = ({ request, session, filename, user }) => ({
  when: actions([Requesting.request, { path: "/FileUploading/requestUploadURL", session, filename }, { request }]),
  where: async (frames) => {
    frames = await frames.query(Sessioning._getUser, { session }, { user })
    return frames
  },
  then: actions([FileUploading.requestUploadURL, { owner: user, filename }]),
});

export const RequestUploadURLResponse: Sync = ({ request, file, uploadURL }) => ({
  when: actions(
    [Requesting.request, { path: "/FileUploading/requestUploadURL" }, { request }],
    [FileUploading.requestUploadURL, {}, { file, uploadURL }],
  ),
  then: actions([Requesting.respond, { request, file, uploadURL }]),
});

//-- Phase 2: Confirm Upload --//
export const ConfirmUploadRequest: Sync = ({ request, session, file, user, owner }) => ({
  when: actions([Requesting.request, { path: "/FileUploading/confirmUpload", session, file }, { request }]),
  where: async (frames) => {
    frames = await frames.query(Sessioning._getUser, { session }, { user });
    frames = await frames.query(FileUploading._getOwner, { file }, { owner });
    return frames.filter(($) => $[user] === $[owner]);
  },
  then: actions([FileUploading.confirmUpload, { file }]),
});

export const ConfirmUploadResponseSuccess: Sync = ({ request, file }) => ({
  when: actions(
    [Requesting.request, { path: "/FileUploading/confirmUpload" }, { request }],
    [FileUploading.confirmUpload, {}, { file }],
  ),
  then: actions([Requesting.respond, { request, status: "confirmed" }]),
});

export const ConfirmUploadResponseError: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/FileUploading/confirmUpload" }, { request }],
    [FileUploading.confirmUpload, {}, { error }],
  ),
  then: actions([Requesting.respond, { request, error }]),
});

//-- List User's Files --//
export const ListMyFilesRequest: Sync = ({ request, session, user, file, filename, results }) => ({
  when: actions([Requesting.request, { path: "/my-files", session }, { request }]),
  where: async (frames) => {
    const originalFrame = frames[0];
    frames = await frames.query(Sessioning._getUser, { session }, { user });
    frames = await frames.query(FileUploading._getFilesByOwner, { owner: user }, { file, filename });
    if (frames.length === 0) {
      const response = {...originalFrame, [results]: []}
      return new Frames(response)
    }
    return frames.collectAs([file, filename], results);
  },
  then: actions([Requesting.respond, { request, results }]),
});

export const ListSharedFilesRequest: Sync = ({ request, session, user, file, filename, owner, ownerUsername, results }) => ({
  when: actions([Requesting.request, { path: "/my-shares", session }, { request }]),
  where: async (frames) => {
    const originalFrame = frames[0];
    
    // 1. Authenticate user
    frames = await frames.query(Sessioning._getUser, { session }, { user });
    
    // If the session is invalid, return an empty list immediately.
    if (frames.length === 0) {
      return new Frames({...originalFrame, [results]: []});
    }
    
    // 2. Find files shared with the user
    frames = await frames.query(Sharing._getFilesSharedWithUser, { user }, { file });
    
    // If no files are shared, return an empty list.
    if (frames.length === 0) {
      return new Frames({...originalFrame, [results]: []});
    }

    // 3. & 4. Enrich each file with its details
    frames = await frames.query(FileUploading._getFilename, { file }, { filename });
    frames = await frames.query(FileUploading._getOwner, { file }, { owner });
    frames = await frames.query(UserAuthentication._getUsername, { user: owner }, { username: ownerUsername });

    // 5. Collect into final response structure
    return frames.collectAs([file, filename, ownerUsername], results);
  },
  then: actions([Requesting.respond, { request, results }]),
});

//-- Download a File --//
export const DownloadFileRequest: Sync = ({ request, session, file, user, owner, isShared, downloadURL }) => ({
  when: actions([Requesting.request, { path: "/download", session, file }, { request }]),
  where: async (frames) => {
    frames = await frames.query(Sessioning._getUser, { session }, { user });
    frames = await frames.query(FileUploading._getOwner, { file }, { owner });
    frames = await frames.query(Sharing._isSharedWith, { file, user }, { access: isShared });
    // Authorization Logic: Keep frames where the user is the owner OR the file is shared.
    frames = frames.filter(($) => $[user] === $[owner] || $[isShared] === true);
    // If any authorized frames remain, get the download URL for them.
    return await frames.query(FileUploading._getDownloadURL, { file }, { downloadURL });
  },
  then: actions([Requesting.respond, { request, downloadURL }]),
});
```
